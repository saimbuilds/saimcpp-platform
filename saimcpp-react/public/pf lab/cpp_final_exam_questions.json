{
  "exam_questions": [
    {
      "question_number": 1,
      "title": "N-Queens Placement Visualizer with Backtracking",
      "category": "2D Arrays & Recursion",
      "marks": 25,
      "time_estimate_minutes": 55,
      "content": "# N-Queens Placement Visualizer (25 Marks)\n\nImplement the N-Queens problem with step-by-step visualization of the backtracking process.\n\n## Problem Statement:\n\nPlace N chess queens on an N\u00d7N chessboard so that no two queens threaten each other. A queen can attack horizontally, vertically, and diagonally.\n\n## Algorithm Visualization:\n\n**Initial Board (N=4):**\n\n| Col 0 | Col 1 | Col 2 | Col 3 |\n|:-----:|:-----:|:-----:|:-----:|\n|   .   |   .   |   .   |   .   |\n|   .   |   .   |   .   |   .   |\n|   .   |   .   |   .   |   .   |\n|   .   |   .   |   .   |   .   |\n\n**Step 1:** Place first queen in row 0, col 0:\n\n| Col 0 | Col 1 | Col 2 | Col 3 |\n|:-----:|:-----:|:-----:|:-----:|\n|   Q   |   X   |   X   |   X   |\n|   X   |   X   |   .   |   .   |\n|   X   |   .   |   X   |   .   |\n|   X   |   .   |   .   |   X   |\n\n**Step 2:** Try row 1, col 2 (safe position):\n\n| Col 0 | Col 1 | Col 2 | Col 3 |\n|:-----:|:-----:|:-----:|:-----:|\n|   Q   |   X   |   X   |   X   |\n|   X   |   X   |   Q   |   X   |\n|   X   |   X   |   X   |   X   |\n|   X   |   X   |   X   |   X   |\n\n**Step 3:** No safe position in row 2, BACKTRACK to row 1...\n\n**Final Solution:**\n\n| Col 0 | Col 1 | Col 2 | Col 3 |\n|:-----:|:-----:|:-----:|:-----:|\n|   .   |   Q   |   .   |   .   |\n|   .   |   .   |   .   |   Q   |\n|   Q   |   .   |   .   |   .   |\n|   .   |   .   |   Q   |   .   |\n\n## Requirements:\n\n- Implement `bool solveNQueens(int** board, int n, int row)`\n- Implement `bool isSafe(int** board, int n, int row, int col)`\n- Use dynamic 2D array allocation\n- Use ONLY pointer arithmetic (no [] operator)\n- Return one valid solution\n- Print board state using 'Q' for queens, '.' for empty\n\n## Constraints:\n\n- 4 \u2264 N \u2264 12\n- Time complexity: O(N!)\n- Space complexity: O(N\u00b2)\n- No global variables allowed\n\n## Function Signatures:\n\n```cpp\nbool isSafe(int** board, int n, int row, int col);\nbool solveNQueens(int** board, int n, int row);\nvoid printBoard(int** board, int n);\n```\n",
      "starter_code": "#include <iostream>\nusing namespace std;\n\nbool isSafe(int** board, int n, int row, int col) {\n    // Check if placing queen at (row, col) is safe\n    // Check column\n    // Check upper-left diagonal\n    // Check upper-right diagonal\n    return true;\n}\n\nbool solveNQueens(int** board, int n, int row) {\n    // Base case: all queens placed\n    // Try placing queen in each column of current row\n    // Recursively solve for next row\n    // Backtrack if needed\n    return false;\n}\n\nvoid printBoard(int** board, int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << (*(*(board + i) + j) ? \"Q \" : \". \");\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    // Allocate 2D board\n    int** board = new int*[n];\n    for (int i = 0; i < n; i++) {\n        *(board + i) = new int[n];\n        for (int j = 0; j < n; j++)\n            *(*(board + i) + j) = 0;\n    }\n    \n    if (solveNQueens(board, n, 0)) {\n        printBoard(board, n);\n    } else {\n        cout << \"NO SOLUTION\" << endl;\n    }\n    \n    // Cleanup\n    for (int i = 0; i < n; i++)\n        delete[] *(board + i);\n    delete[] board;\n    \n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "4",
          "output": ". Q . .\n. . . Q\nQ . . .\n. . Q .",
          "explanation": "For N=4, queens placed at (0,1), (1,3), (2,0), (3,2). No two queens share row, column, or diagonal."
        },
        {
          "input": "8",
          "output": "Q . . . . . . .\n. . . . Q . . .\n. . . . . . . Q\n. . . . . Q . .\n. . Q . . . . .\n. . . . . . Q .\n. Q . . . . . .\n. . . Q . . . .",
          "explanation": "Classic 8-queens solution. One of 92 possible solutions."
        }
      ],
      "hidden_test_cases": [
        {
          "input": "5",
          "output": "Q . . . .\n. . Q . .\n. . . . Q\n. Q . . .\n. . . Q ."
        },
        {
          "input": "6",
          "output": ". Q . . . .\n. . . Q . .\n. . . . . Q\nQ . . . . .\n. . Q . . .\n. . . . Q ."
        },
        {
          "input": "9",
          "output": "Q . . . . . . . .\n. . Q . . . . . .\n. . . . Q . . . .\n. . . . . . Q . .\n. . . . . . . . Q\n. Q . . . . . . .\n. . . Q . . . . .\n. . . . . Q . . .\n. . . . . . . Q ."
        },
        {
          "input": "10",
          "output": "Q . . . . . . . . .\n. . Q . . . . . . .\n. . . . Q . . . . .\n. . . . . . Q . . .\n. . . . . . . . Q .\n. Q . . . . . . . .\n. . . Q . . . . . .\n. . . . . Q . . . .\n. . . . . . . Q . .\n. . . . . . . . . Q"
        },
        {
          "input": "12",
          "output": "Q . . . . . . . . . . .\n. . Q . . . . . . . . .\n. . . . Q . . . . . . .\n. . . . . . Q . . . . .\n. . . . . . . . Q . . .\n. . . . . . . . . . Q .\n. Q . . . . . . . . . .\n. . . Q . . . . . . . .\n. . . . . Q . . . . . .\n. . . . . . . Q . . . .\n. . . . . . . . . Q . .\n. . . . . . . . . . . Q"
        }
      ]
    },
    {
      "question_number": 2,
      "title": "Spiral Matrix Constructor with Dynamic Patterns",
      "category": "2D Arrays & Pointer Arithmetic",
      "marks": 25,
      "time_estimate_minutes": 52,
      "content": "# Spiral Matrix Constructor (25 Marks)\n\nConstruct an N\u00d7N matrix by filling numbers from 1 to N\u00b2 in a spiral pattern (clockwise from outside to inside).\n\n## Problem Statement:\n\nGiven N, create a matrix where numbers are placed in a clockwise spiral:\n\n**N=3 Example:**\n\n**Step 1:** Fill top row (left to right):\n\n| Col 0 | Col 1 | Col 2 |\n|:-----:|:-----:|:-----:|\n|   1   |   2   |   3   |\n|       |       |       |\n|       |       |       |\n\n**Step 2:** Fill right column (top to bottom):\n\n| Col 0 | Col 1 | Col 2 |\n|:-----:|:-----:|:-----:|\n|   1   |   2   |   3   |\n|       |       |   4   |\n|       |       |   5   |\n\n**Step 3:** Fill bottom row (right to left):\n\n| Col 0 | Col 1 | Col 2 |\n|:-----:|:-----:|:-----:|\n|   1   |   2   |   3   |\n|       |       |   4   |\n|   7   |   6   |   5   |\n\n**Step 4:** Fill left column (bottom to top):\n\n| Col 0 | Col 1 | Col 2 |\n|:-----:|:-----:|:-----:|\n|   1   |   2   |   3   |\n|   8   |       |   4   |\n|   7   |   6   |   5   |\n\n**Step 5:** Fill inner layer:\n\n| Col 0 | Col 1 | Col 2 |\n|:-----:|:-----:|:-----:|\n|   1   |   2   |   3   |\n|   8   |   9   |   4   |\n|   7   |   6   |   5   |\n\n**N=5 Final Result:**\n\n|  1 |  2 |  3 |  4 |  5 |\n|:--:|:--:|:--:|:--:|:--:|\n| 16 | 17 | 18 | 19 |  6 |\n| 15 | 24 | 25 | 20 |  7 |\n| 14 | 23 | 22 | 21 |  8 |\n| 13 | 12 | 11 | 10 |  9 |\n\n## Requirements:\n\n- Implement `void fillSpiral(int** matrix, int n)`\n- Use dynamic memory allocation\n- Track boundaries: top, bottom, left, right\n- Use ONLY pointer arithmetic\n- Handle edge case when N=1\n\n## Constraints:\n\n- 1 \u2264 N \u2264 50\n- Time complexity: O(N\u00b2)\n- Space complexity: O(N\u00b2)\n- Must use 4-direction approach\n\n## Function Signatures:\n\n```cpp\nvoid fillSpiral(int** matrix, int n);\nvoid printMatrix(int** matrix, int n);\n```\n",
      "starter_code": "#include <iostream>\nusing namespace std;\n\nvoid fillSpiral(int** matrix, int n) {\n    int top = 0, bottom = n - 1;\n    int left = 0, right = n - 1;\n    int num = 1;\n    \n    while (top <= bottom && left <= right) {\n        // Fill top row\n        \n        // Fill right column\n        \n        // Fill bottom row\n        \n        // Fill left column\n        \n    }\n}\n\nvoid printMatrix(int** matrix, int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << *(*(matrix + i) + j) << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    int** matrix = new int*[n];\n    for (int i = 0; i < n; i++)\n        *(matrix + i) = new int[n];\n    \n    fillSpiral(matrix, n);\n    printMatrix(matrix, n);\n    \n    for (int i = 0; i < n; i++)\n        delete[] *(matrix + i);\n    delete[] matrix;\n    \n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "3",
          "output": "1 2 3\n8 9 4\n7 6 5",
          "explanation": "3\u00d73 spiral fills clockwise from outside to center."
        },
        {
          "input": "5",
          "output": "1 2 3 4 5\n16 17 18 19 6\n15 24 25 20 7\n14 23 22 21 8\n13 12 11 10 9",
          "explanation": "5\u00d75 spiral with nested layers."
        }
      ],
      "hidden_test_cases": [
        {
          "input": "1",
          "output": "1"
        },
        {
          "input": "2",
          "output": "1 2\n4 3"
        },
        {
          "input": "4",
          "output": "1 2 3 4\n12 13 14 5\n11 16 15 6\n10 9 8 7"
        },
        {
          "input": "6",
          "output": "1 2 3 4 5 6\n20 21 22 23 24 7\n19 32 33 34 25 8\n18 31 36 35 26 9\n17 30 29 28 27 10\n16 15 14 13 12 11"
        },
        {
          "input": "10",
          "output": "1 2 3 4 5 6 7 8 9 10\n36 37 38 39 40 41 42 43 44 11\n35 64 65 66 67 68 69 70 45 12\n34 63 84 85 86 87 88 71 46 13\n33 62 83 96 97 98 89 72 47 14\n32 61 82 95 100 99 90 73 48 15\n31 60 81 94 93 92 91 74 49 16\n30 59 80 79 78 77 76 75 50 17\n29 58 57 56 55 54 53 52 51 18\n28 27 26 25 24 23 22 21 20 19"
        }
      ]
    },
    {
      "question_number": 3,
      "title": "Matrix Rotation with In-Place Transformation",
      "category": "2D Arrays & Pointer Manipulation",
      "marks": 25,
      "time_estimate_minutes": 58,
      "content": "# Matrix Rotation 90\u00b0 Clockwise (25 Marks)\n\nRotate an N\u00d7N matrix 90 degrees clockwise IN-PLACE without using extra space.\n\n## Problem Statement:\n\nGiven a matrix, rotate it 90\u00b0 clockwise using only O(1) extra space.\n\n## Rotation Process (N=4):\n\n**Original Matrix:**\n\n|  1 |  2 |  3 |  4 |\n|:--:|:--:|:--:|:--:|\n|  5 |  6 |  7 |  8 |\n|  9 | 10 | 11 | 12 |\n| 13 | 14 | 15 | 16 |\n\n**Step 1:** Transpose matrix (swap across diagonal):\n\n|  1 |  5 |  9 | 13 |\n|:--:|:--:|:--:|:--:|\n|  2 |  6 | 10 | 14 |\n|  3 |  7 | 11 | 15 |\n|  4 |  8 | 12 | 16 |\n\n**Step 2:** Reverse each row:\n\n| 13 |  9 |  5 |  1 |\n|:--:|:--:|:--:|:--:|\n| 14 | 10 |  6 |  2 |\n| 15 | 11 |  7 |  3 |\n| 16 | 12 |  8 |  4 |\n\n**Result:** Matrix rotated 90\u00b0 clockwise!\n\n## Layer-by-Layer Approach:\n\nFor 5\u00d75 matrix, process 2 layers:\n\n**Layer 0 (outer):** Rotate elements at boundaries\n**Layer 1 (inner):** Rotate inner 3\u00d73 matrix\n\n**Original 5\u00d75:**\n\n|  1 |  2 |  3 |  4 |  5 |\n|:--:|:--:|:--:|:--:|:--:|\n|  6 |  7 |  8 |  9 | 10 |\n| 11 | 12 | 13 | 14 | 15 |\n| 16 | 17 | 18 | 19 | 20 |\n| 21 | 22 | 23 | 24 | 25 |\n\n**After Rotation:**\n\n| 21 | 16 | 11 |  6 |  1 |\n|:--:|:--:|:--:|:--:|:--:|\n| 22 | 17 | 12 |  7 |  2 |\n| 23 | 18 | 13 |  8 |  3 |\n| 24 | 19 | 14 |  9 |  4 |\n| 25 | 20 | 15 | 10 |  5 |\n\n## Requirements:\n\n- Implement `void rotateMatrix(int** mat, int n)`\n- Use in-place rotation (O(1) extra space)\n- Use ONLY pointer arithmetic\n- Handle both transpose and layer approaches\n- Support K rotations (K % 4 gives effective rotations)\n\n## Constraints:\n\n- 1 \u2264 N \u2264 100\n- 1 \u2264 K \u2264 1000 (number of rotations)\n- Time complexity: O(N\u00b2)\n- Space complexity: O(1)\n\n## Function Signatures:\n\n```cpp\nvoid rotateMatrix(int** mat, int n);\nvoid transpose(int** mat, int n);\nvoid reverseRows(int** mat, int n);\n```\n",
      "starter_code": "#include <iostream>\nusing namespace std;\n\nvoid transpose(int** mat, int n) {\n    // Swap elements across diagonal\n}\n\nvoid reverseRows(int** mat, int n) {\n    // Reverse each row\n}\n\nvoid rotateMatrix(int** mat, int n) {\n    // Approach 1: Transpose + Reverse rows\n    // OR\n    // Approach 2: Layer-by-layer rotation\n}\n\nvoid printMatrix(int** mat, int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\n            cout << *(*(mat + i) + j) << \" \";\n        cout << endl;\n    }\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    int** mat = new int*[n];\n    for (int i = 0; i < n; i++) {\n        *(mat + i) = new int[n];\n        for (int j = 0; j < n; j++)\n            cin >> *(*(mat + i) + j);\n    }\n    \n    k = k % 4; // Optimize rotations\n    for (int i = 0; i < k; i++)\n        rotateMatrix(mat, n);\n    \n    printMatrix(mat, n);\n    \n    for (int i = 0; i < n; i++)\n        delete[] *(mat + i);\n    delete[] mat;\n    \n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "3 1\n1 2 3\n4 5 6\n7 8 9",
          "output": "7 4 1\n8 5 2\n9 6 3",
          "explanation": "3\u00d73 matrix rotated 90\u00b0 clockwise once."
        },
        {
          "input": "4 2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16",
          "output": "16 15 14 13\n12 11 10 9\n8 7 6 5\n4 3 2 1",
          "explanation": "4\u00d74 matrix rotated 180\u00b0 (2 times 90\u00b0)."
        }
      ],
      "hidden_test_cases": [
        {
          "input": "1 1\n42",
          "output": "42"
        },
        {
          "input": "2 3\n1 2\n3 4",
          "output": "2 4\n1 3"
        },
        {
          "input": "5 1\n1 2 3 4 5\n6 7 8 9 10\n11 12 13 14 15\n16 17 18 19 20\n21 22 23 24 25",
          "output": "21 16 11 6 1\n22 17 12 7 2\n23 18 13 8 3\n24 19 14 9 4\n25 20 15 10 5"
        },
        {
          "input": "6 4\n1 2 3 4 5 6\n7 8 9 10 11 12\n13 14 15 16 17 18\n19 20 21 22 23 24\n25 26 27 28 29 30\n31 32 33 34 35 36",
          "output": "1 2 3 4 5 6\n7 8 9 10 11 12\n13 14 15 16 17 18\n19 20 21 22 23 24\n25 26 27 28 29 30\n31 32 33 34 35 36"
        },
        {
          "input": "7 5\n1 2 3 4 5 6 7\n8 9 10 11 12 13 14\n15 16 17 18 19 20 21\n22 23 24 25 26 27 28\n29 30 31 32 33 34 35\n36 37 38 39 40 41 42\n43 44 45 46 47 48 49",
          "output": "43 36 29 22 15 8 1\n44 37 30 23 16 9 2\n45 38 31 24 17 10 3\n46 39 32 25 18 11 4\n47 40 33 26 19 12 5\n48 41 34 27 20 13 6\n49 42 35 28 21 14 7"
        }
      ]
    },
    {
      "question_number": 4,
      "title": "Suffix Array Construction with LCP Optimization",
      "category": "Arrays & Sorting Algorithms",
      "marks": 25,
      "time_estimate_minutes": 60,
      "content": "# Suffix Array with LCP Array (25 Marks)\n\nConstruct a suffix array and Longest Common Prefix (LCP) array for efficient string processing.\n\n## Problem Statement:\n\nGiven a string S, create:\n1. **Suffix Array**: Sorted array of all suffix starting positions\n2. **LCP Array**: Length of longest common prefix between adjacent suffixes\n\n## Example for S = \"banana\":\n\n**All Suffixes:**\n\n| Index | Suffix  |\n|:-----:|:-------:|\n|   0   | banana  |\n|   1   | anana   |\n|   2   | nana    |\n|   3   | ana     |\n|   4   | na      |\n|   5   | a       |\n\n**Sorted Suffixes (Suffix Array):**\n\n| Position | Original Index | Suffix  |\n|:--------:|:--------------:|:-------:|\n|    0     |       5        |    a    |\n|    1     |       3        |   ana   |\n|    2     |       1        |  anana  |\n|    3     |       0        | banana  |\n|    4     |       4        |   na    |\n|    5     |       2        |  nana   |\n\n**Suffix Array:** [5, 3, 1, 0, 4, 2]\n\n**LCP Array Calculation:**\n\n| i | SA[i] | SA[i+1] | Suffix[SA[i]]  | Suffix[SA[i+1]] | LCP |\n|:-:|:-----:|:-------:|:--------------:|:---------------:|:---:|\n| 0 |   5   |    3    |       a        |      ana        |  1  |\n| 1 |   3   |    1    |      ana       |     anana       |  3  |\n| 2 |   1   |    0    |     anana      |    banana       |  0  |\n| 3 |   0   |    4    |    banana      |      na         |  0  |\n| 4 |   4   |    2    |      na        |     nana        |  2  |\n\n**LCP Array:** [1, 3, 0, 0, 2]\n\n## Requirements:\n\n- Implement `void buildSuffixArray(char* str, int* suffixArr, int n)`\n- Implement `void buildLCPArray(char* str, int* suffixArr, int* lcp, int n)`\n- Use efficient O(n log n) sorting with ranking\n- Use ONLY pointer arithmetic\n- Handle duplicate characters\n\n## Constraints:\n\n- 1 \u2264 |S| \u2264 10,000\n- String contains only lowercase letters\n- Time complexity: O(n log\u00b2n) acceptable\n- Space complexity: O(n)\n\n## Algorithm Hint:\n\n1. Create suffix structure with index and rank\n2. Sort by first character, then first 2 chars, 4 chars, etc.\n3. Update ranks after each sorting phase\n4. Build LCP using Kasai's algorithm\n\n## Function Signatures:\n\n```cpp\nvoid buildSuffixArray(char* str, int* suffixArr, int n);\nvoid buildLCPArray(char* str, int* suffixArr, int* lcp, int n);\nint compareSubstrings(char* str, int i, int j, int len);\n```\n",
      "starter_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nstruct Suffix {\n    int index;\n    int rank[2];\n};\n\nint cmp(const void* a, const void* b) {\n    Suffix* s1 = (Suffix*)a;\n    Suffix* s2 = (Suffix*)b;\n    if (s1->rank[0] != s2->rank[0])\n        return s1->rank[0] - s2->rank[0];\n    return s1->rank[1] - s2->rank[1];\n}\n\nvoid buildSuffixArray(char* str, int* suffixArr, int n) {\n    Suffix* suffixes = new Suffix[n];\n    \n    // Initialize suffixes\n    for (int i = 0; i < n; i++) {\n        suffixes[i].index = i;\n        suffixes[i].rank[0] = *(str + i) - 'a';\n        suffixes[i].rank[1] = (i + 1 < n) ? (*(str + i + 1) - 'a') : -1;\n    }\n    \n    // Sort based on first 2 characters\n    // Then double the length each iteration\n    \n    // Extract suffix array\n    for (int i = 0; i < n; i++)\n        *(suffixArr + i) = suffixes[i].index;\n    \n    delete[] suffixes;\n}\n\nvoid buildLCPArray(char* str, int* suffixArr, int* lcp, int n) {\n    int* rank = new int[n];\n    \n    // Build rank array from suffix array\n    for (int i = 0; i < n; i++)\n        *(rank + *(suffixArr + i)) = i;\n    \n    // Kasai's algorithm for LCP\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n        if (*(rank + i) == n - 1) {\n            k = 0;\n            continue;\n        }\n        \n        int j = *(suffixArr + *(rank + i) + 1);\n        \n        // Find LCP\n        while (i + k < n && j + k < n && *(str + i + k) == *(str + j + k))\n            k++;\n        \n        *(lcp + *(rank + i)) = k;\n        \n        if (k > 0)\n            k--;\n    }\n    \n    delete[] rank;\n}\n\nint main() {\n    char str[10001];\n    cin >> str;\n    \n    int n = strlen(str);\n    int* suffixArr = new int[n];\n    int* lcp = new int[n];\n    \n    buildSuffixArray(str, suffixArr, n);\n    buildLCPArray(str, suffixArr, lcp, n);\n    \n    cout << \"Suffix Array: \";\n    for (int i = 0; i < n; i++)\n        cout << *(suffixArr + i) << \" \";\n    cout << endl;\n    \n    cout << \"LCP Array: \";\n    for (int i = 0; i < n - 1; i++)\n        cout << *(lcp + i) << \" \";\n    cout << endl;\n    \n    delete[] suffixArr;\n    delete[] lcp;\n    \n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "banana",
          "output": "Suffix Array: 5 3 1 0 4 2\nLCP Array: 1 3 0 0 2",
          "explanation": "Suffixes sorted lexicographically: a, ana, anana, banana, na, nana"
        },
        {
          "input": "abcab",
          "output": "Suffix Array: 0 2 4 1 3\nLCP Array: 2 0 1 1",
          "explanation": "Suffixes: ab(0), ab(2), b(4), bcab(1), cab(3)"
        }
      ],
      "hidden_test_cases": [
        {
          "input": "a",
          "output": "Suffix Array: 0\nLCP Array:"
        },
        {
          "input": "aaa",
          "output": "Suffix Array: 2 1 0\nLCP Array: 1 2"
        },
        {
          "input": "abracadabra",
          "output": "Suffix Array: 10 7 0 3 5 8 1 4 6 9 2\nLCP Array: 1 4 1 1 0 3 0 0 0 2"
        },
        {
          "input": "mississippi",
          "output": "Suffix Array: 10 7 4 1 0 9 8 6 3 5 2\nLCP Array: 1 1 4 0 0 1 0 2 1 3"
        },
        {
          "input": "programming",
          "output": "Suffix Array: 9 2 3 10 4 0 8 6 1 5 7\nLCP Array: 0 1 0 2 0 1 1 2 1 0"
        }
      ]
    },
    {
      "question_number": 5,
      "title": "University Course Registration System with Conflicts",
      "category": "Dynamic Arrays & Linked Structures",
      "marks": 25,
      "time_estimate_minutes": 55,
      "content": "# University Course Registration System (25 Marks)\n\nImplement a course registration system that handles enrollment, waitlists, prerequisites, and time conflicts.\n\n## System Requirements:\n\n### Data Structures:\n\n**Course:**\n- Course code (string)\n- Capacity (max students)\n- Enrolled students array (dynamic)\n- Waitlist array (dynamic)\n- Prerequisites array\n- Time slot (start hour, end hour)\n\n**Student:**\n- Student ID\n- Enrolled courses array (dynamic)\n- Total credits\n\n### Operations:\n\n1. **Enroll Student**: Add to course if:\n   - Not at capacity\n   - Prerequisites met\n   - No time conflict with enrolled courses\n   - Otherwise add to waitlist\n\n2. **Drop Course**: Remove student, promote from waitlist\n\n3. **Check Conflicts**: Detect time overlaps\n\n## Example Scenario:\n\n**Courses Available:**\n\n| Code  | Capacity | Time Slot | Prerequisites |\n|:-----:|:--------:|:---------:|:-------------:|\n| CS101 |    30    |  9-11 AM  |     None      |\n| CS201 |    25    |  10-12 PM |    CS101      |\n| MATH  |    40    |  9-11 AM  |     None      |\n| PHY   |    35    |  2-4 PM   |     None      |\n\n**Student Actions:**\n\n| Step | Action                      | Result                        |\n|:----:|:---------------------------:|:-----------------------------:|\n|  1   | Enroll in CS101             | SUCCESS (enrolled)            |\n|  2   | Enroll in CS201             | FAIL (prerequisite not met)   |\n|  3   | Complete CS101              | CS101 marked complete         |\n|  4   | Enroll in CS201             | SUCCESS                       |\n|  5   | Enroll in MATH              | FAIL (time conflict 9-11)     |\n|  6   | Enroll in PHY               | SUCCESS (no conflict)         |\n\n**Final Enrollment:**\n- CS101: Completed\n- CS201: Enrolled (10-12)\n- PHY: Enrolled (2-4)\n\n## Requirements:\n\n- Implement `bool enrollStudent(Course* course, Student* student)`\n- Implement `bool checkTimeConflict(Student* student, int start, int end)`\n- Implement `bool checkPrerequisites(Student* student, Course* course)`\n- Implement `void promoteFromWaitlist(Course* course)`\n- Use dynamic arrays (resize when needed)\n- Use ONLY pointer arithmetic\n\n## Constraints:\n\n- 1 \u2264 Number of courses \u2264 100\n- 1 \u2264 Number of students \u2264 1000\n- 1 \u2264 Course capacity \u2264 200\n- Time slots: 8 AM - 8 PM (24-hour format)\n- Handle memory leaks properly\n\n## Input Format:\n```\nN M K\nN courses (code, capacity, startTime, endTime, numPrereqs, prereqs...)\nM students (ID)\nK operations (ENROLL/DROP studentID courseCode)\n```\n\n## Output Format:\n```\nFor each operation:\nSUCCESS / FAIL: reason\nFinal enrollment report\n```\n\n## Function Signatures:\n\n```cpp\nstruct Course {\n    char code[10];\n    int capacity;\n    int* enrolled;\n    int enrolledCount;\n    int* waitlist;\n    int waitlistCount;\n    char prerequisites[5][10];\n    int numPrereqs;\n    int startTime, endTime;\n};\n\nstruct Student {\n    int id;\n    char** enrolledCourses;\n    int courseCount;\n    char** completedCourses;\n    int completedCount;\n};\n\nbool enrollStudent(Course* course, Student* student);\nbool checkTimeConflict(Student* student, int start, int end);\nvoid promoteFromWaitlist(Course* course);\n```\n",
      "starter_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nstruct Course {\n    char code[10];\n    int capacity;\n    int* enrolled;\n    int enrolledCount;\n    int* waitlist;\n    int waitlistCount;\n    char prerequisites[5][10];\n    int numPrereqs;\n    int startTime, endTime;\n};\n\nstruct Student {\n    int id;\n    char** enrolledCourses;\n    int courseCount;\n    char** completedCourses;\n    int completedCount;\n};\n\nbool checkPrerequisites(Student* student, Course* course) {\n    // Check if student completed all prerequisites\n    return true;\n}\n\nbool checkTimeConflict(Student* student, Course* courses, int numCourses, Course* newCourse) {\n    // Check if newCourse conflicts with student's enrolled courses\n    return false;\n}\n\nbool enrollStudent(Course* course, Student* student, Course* allCourses, int numCourses) {\n    // Check prerequisites\n    // Check time conflicts\n    // Enroll if capacity available, else waitlist\n    return false;\n}\n\nvoid dropCourse(Course* course, Student* student) {\n    // Remove student from course\n    // Promote from waitlist if available\n}\n\nvoid promoteFromWaitlist(Course* course, Student* students, int numStudents) {\n    // Move first student from waitlist to enrolled\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    Course* courses = new Course[n];\n    Student* students = new Student[m];\n    \n    // Read courses\n    for (int i = 0; i < n; i++) {\n        cin >> courses[i].code >> courses[i].capacity;\n        cin >> courses[i].startTime >> courses[i].endTime;\n        cin >> courses[i].numPrereqs;\n        for (int j = 0; j < courses[i].numPrereqs; j++)\n            cin >> courses[i].prerequisites[j];\n        \n        courses[i].enrolled = new int[courses[i].capacity];\n        courses[i].enrolledCount = 0;\n        courses[i].waitlist = new int[100];\n        courses[i].waitlistCount = 0;\n    }\n    \n    // Read students\n    for (int i = 0; i < m; i++) {\n        cin >> students[i].id;\n        students[i].enrolledCourses = new char*[10];\n        students[i].courseCount = 0;\n        students[i].completedCourses = new char*[20];\n        students[i].completedCount = 0;\n    }\n    \n    // Process operations\n    for (int i = 0; i < k; i++) {\n        char operation[10];\n        int studentID;\n        char courseCode[10];\n        cin >> operation >> studentID >> courseCode;\n        \n        // Find student and course\n        Student* student = nullptr;\n        Course* course = nullptr;\n        \n        for (int j = 0; j < m; j++)\n            if (students[j].id == studentID)\n                student = &students[j];\n        \n        for (int j = 0; j < n; j++)\n            if (strcmp(courses[j].code, courseCode) == 0)\n                course = &courses[j];\n        \n        if (strcmp(operation, \"ENROLL\") == 0) {\n            if (enrollStudent(course, student, courses, n))\n                cout << \"SUCCESS\" << endl;\n            else\n                cout << \"FAIL\" << endl;\n        } else if (strcmp(operation, \"DROP\") == 0) {\n            dropCourse(course, student);\n            cout << \"DROPPED\" << endl;\n        }\n    }\n    \n    // Cleanup\n    delete[] courses;\n    delete[] students;\n    \n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "3 2 4\nCS101 30 9 11 0\nCS201 25 10 12 1 CS101\nMATH 40 9 11 0\n1001\n1002\nENROLL 1001 CS101\nENROLL 1001 CS201\nENROLL 1001 MATH\nENROLL 1002 CS101",
          "output": "SUCCESS\nFAIL\nFAIL\nSUCCESS",
          "explanation": "Student 1001: Enrolls in CS101, fails CS201 (prereq), fails MATH (conflict). Student 1002: Enrolls in CS101."
        },
        {
          "input": "2 3 5\nPHY 2 14 16 0\nCHEM 2 14 16 0\n2001\n2002\n2003\nENROLL 2001 PHY\nENROLL 2002 PHY\nENROLL 2003 PHY\nDROP 2001 PHY\nENROLL 2003 PHY",
          "output": "SUCCESS\nSUCCESS\nFAIL\nDROPPED\nSUCCESS",
          "explanation": "PHY capacity=2. First 2 students enroll, 3rd waitlisted. After drop, promoted from waitlist."
        }
      ],
      "hidden_test_cases": [
        {
          "input": "1 1 1\nCS101 50 9 11 0\n1001\nENROLL 1001 CS101",
          "output": "SUCCESS"
        },
        {
          "input": "4 1 4\nA 10 9 10 0\nB 10 10 11 0\nC 10 11 12 0\nD 10 9 12 0\n1001\nENROLL 1001 A\nENROLL 1001 B\nENROLL 1001 C\nENROLL 1001 D",
          "output": "SUCCESS\nSUCCESS\nSUCCESS\nFAIL"
        },
        {
          "input": "3 2 6\nCS101 1 9 11 0\nCS201 1 13 15 1 CS101\nCS301 1 16 18 1 CS201\n3001\n3002\nENROLL 3001 CS101\nENROLL 3002 CS101\nDROP 3001 CS101\nENROLL 3002 CS201\nDROP 3002 CS101\nENROLL 3002 CS301",
          "output": "SUCCESS\nFAIL\nDROPPED\nFAIL\nDROPPED\nFAIL"
        },
        {
          "input": "5 5 10\nA 2 8 10 0\nB 2 10 12 0\nC 2 12 14 0\nD 2 14 16 0\nE 2 16 18 0\n4001\n4002\n4003\n4004\n4005\nENROLL 4001 A\nENROLL 4001 B\nENROLL 4002 A\nENROLL 4002 C\nENROLL 4003 A\nENROLL 4003 B\nENROLL 4004 B\nENROLL 4005 C\nDROP 4001 A\nDROP 4001 B",
          "output": "SUCCESS\nSUCCESS\nSUCCESS\nSUCCESS\nFAIL\nFAIL\nSUCCESS\nSUCCESS\nDROPPED\nDROPPED"
        },
        {
          "input": "2 10 20\nPOP 3 9 11 0\nREG 3 13 15 0\n5001\n5002\n5003\n5004\n5005\n5006\n5007\n5008\n5009\n5010\nENROLL 5001 POP\nENROLL 5002 POP\nENROLL 5003 POP\nENROLL 5004 POP\nENROLL 5005 REG\nENROLL 5006 REG\nENROLL 5007 REG\nENROLL 5008 REG\nDROP 5001 POP\nDROP 5002 POP\nENROLL 5001 REG\nENROLL 5002 REG\nDROP 5005 REG\nDROP 5006 REG\nENROLL 5009 POP\nENROLL 5010 POP\nENROLL 5009 REG\nENROLL 5010 REG\nDROP 5003 POP\nDROP 5004 POP",
          "output": "SUCCESS\nSUCCESS\nSUCCESS\nFAIL\nSUCCESS\nSUCCESS\nSUCCESS\nFAIL\nDROPPED\nDROPPED\nFAIL\nFAIL\nDROPPED\nDROPPED\nSUCCESS\nFAIL\nSUCCESS\nSUCCESS\nDROPPED\nDROPPED"
        }
      ]
    },
    {
      "question_number": 6,
      "title": "Sudoku Solver with Backtracking Visualization",
      "category": "2D Arrays & Recursion",
      "marks": 25,
      "time_estimate_minutes": 58,
      "content": "# Sudoku Solver with Backtracking (25 Marks)\n\nSolve a 9\u00d79 Sudoku puzzle using backtracking algorithm.\n\n## Problem Statement:\n\nFill a partially filled 9\u00d79 grid so that:\n- Each row contains digits 1-9 without repetition\n- Each column contains digits 1-9 without repetition\n- Each 3\u00d73 sub-grid contains digits 1-9 without repetition\n\n## Example Puzzle:\n\n**Initial State (0 = empty):**\n\n| 5 | 3 | 0 | 0 | 7 | 0 | 0 | 0 | 0 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| 6 | 0 | 0 | 1 | 9 | 5 | 0 | 0 | 0 |\n| 0 | 9 | 8 | 0 | 0 | 0 | 0 | 6 | 0 |\n| 8 | 0 | 0 | 0 | 6 | 0 | 0 | 0 | 3 |\n| 4 | 0 | 0 | 8 | 0 | 3 | 0 | 0 | 1 |\n| 7 | 0 | 0 | 0 | 2 | 0 | 0 | 0 | 6 |\n| 0 | 6 | 0 | 0 | 0 | 0 | 2 | 8 | 0 |\n| 0 | 0 | 0 | 4 | 1 | 9 | 0 | 0 | 5 |\n| 0 | 0 | 0 | 0 | 8 | 0 | 0 | 7 | 9 |\n\n**Step-by-Step Solution Process:**\n\n**Step 1:** Find first empty cell (0,2), try digits 1-9\n- Try 1: Check row 0, column 2, box (0,0)-(2,2)\n- 1 is valid, place it\n\n**Step 2:** Move to next empty (0,3)\n- Try 1: Invalid (already in row)\n- Try 2: Valid, place it\n\n**Continue until solved or backtrack when stuck...**\n\n**Final Solution:**\n\n| 5 | 3 | 4 | 6 | 7 | 8 | 9 | 1 | 2 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| 6 | 7 | 2 | 1 | 9 | 5 | 3 | 4 | 8 |\n| 1 | 9 | 8 | 3 | 4 | 2 | 5 | 6 | 7 |\n| 8 | 5 | 9 | 7 | 6 | 1 | 4 | 2 | 3 |\n| 4 | 2 | 6 | 8 | 5 | 3 | 7 | 9 | 1 |\n| 7 | 1 | 3 | 9 | 2 | 4 | 8 | 5 | 6 |\n| 9 | 6 | 1 | 5 | 3 | 7 | 2 | 8 | 4 |\n| 2 | 8 | 7 | 4 | 1 | 9 | 6 | 3 | 5 |\n| 3 | 4 | 5 | 2 | 8 | 6 | 1 | 7 | 9 |\n\n## Requirements:\n\n- Implement `bool solveSudoku(int** grid)`\n- Implement `bool isSafe(int** grid, int row, int col, int num)`\n- Implement `bool findEmpty(int** grid, int& row, int& col)`\n- Use backtracking recursion\n- Use ONLY pointer arithmetic\n- Modify grid in-place\n\n## Constraints:\n\n- Grid is always 9\u00d79\n- 0 represents empty cells\n- Input has exactly one solution\n- Time complexity: O(9^(n*n)) worst case\n- Space complexity: O(1) excluding recursion stack\n\n## Function Signatures:\n\n```cpp\nbool isSafe(int** grid, int row, int col, int num);\nbool findEmpty(int** grid, int& row, int& col);\nbool solveSudoku(int** grid);\n```\n",
      "starter_code": "#include <iostream>\nusing namespace std;\n\nbool isSafe(int** grid, int row, int col, int num) {\n    // Check row\n    for (int x = 0; x < 9; x++)\n        if (*(*(grid + row) + x) == num)\n            return false;\n    \n    // Check column\n    for (int x = 0; x < 9; x++)\n        if (*(*(grid + x) + col) == num)\n            return false;\n    \n    // Check 3x3 box\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            if (*(*(grid + i + startRow) + j + startCol) == num)\n                return false;\n    \n    return true;\n}\n\nbool findEmpty(int** grid, int& row, int& col) {\n    for (row = 0; row < 9; row++)\n        for (col = 0; col < 9; col++)\n            if (*(*(grid + row) + col) == 0)\n                return true;\n    return false;\n}\n\nbool solveSudoku(int** grid) {\n    int row, col;\n    \n    // If no empty cell, puzzle solved\n    if (!findEmpty(grid, row, col))\n        return true;\n    \n    // Try digits 1-9\n    for (int num = 1; num <= 9; num++) {\n        if (isSafe(grid, row, col, num)) {\n            // Place number\n            *(*(grid + row) + col) = num;\n            \n            // Recursively solve\n            if (solveSudoku(grid))\n                return true;\n            \n            // Backtrack\n            *(*(grid + row) + col) = 0;\n        }\n    }\n    \n    return false;\n}\n\nvoid printGrid(int** grid) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++)\n            cout << *(*(grid + i) + j) << \" \";\n        cout << endl;\n    }\n}\n\nint main() {\n    int** grid = new int*[9];\n    for (int i = 0; i < 9; i++) {\n        *(grid + i) = new int[9];\n        for (int j = 0; j < 9; j++)\n            cin >> *(*(grid + i) + j);\n    }\n    \n    if (solveSudoku(grid)) {\n        printGrid(grid);\n    } else {\n        cout << \"NO SOLUTION\" << endl;\n    }\n    \n    for (int i = 0; i < 9; i++)\n        delete[] *(grid + i);\n    delete[] grid;\n    \n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "5 3 0 0 7 0 0 0 0\n6 0 0 1 9 5 0 0 0\n0 9 8 0 0 0 0 6 0\n8 0 0 0 6 0 0 0 3\n4 0 0 8 0 3 0 0 1\n7 0 0 0 2 0 0 0 6\n0 6 0 0 0 0 2 8 0\n0 0 0 4 1 9 0 0 5\n0 0 0 0 8 0 0 7 9",
          "output": "5 3 4 6 7 8 9 1 2\n6 7 2 1 9 5 3 4 8\n1 9 8 3 4 2 5 6 7\n8 5 9 7 6 1 4 2 3\n4 2 6 8 5 3 7 9 1\n7 1 3 9 2 4 8 5 6\n9 6 1 5 3 7 2 8 4\n2 8 7 4 1 9 6 3 5\n3 4 5 2 8 6 1 7 9",
          "explanation": "Classic Sudoku puzzle solved using backtracking."
        },
        {
          "input": "0 0 0 2 6 0 7 0 1\n6 8 0 0 7 0 0 9 0\n1 9 0 0 0 4 5 0 0\n8 2 0 1 0 0 0 4 0\n0 0 4 6 0 2 9 0 0\n0 5 0 0 0 3 0 2 8\n0 0 9 3 0 0 0 7 4\n0 4 0 0 5 0 0 3 6\n7 0 3 0 1 8 0 0 0",
          "output": "4 3 5 2 6 9 7 8 1\n6 8 2 5 7 1 4 9 3\n1 9 7 8 3 4 5 6 2\n8 2 6 1 9 5 3 4 7\n3 7 4 6 8 2 9 1 5\n9 5 1 7 4 3 6 2 8\n5 1 9 3 2 6 8 7 4\n2 4 8 9 5 7 1 3 6\n7 6 3 4 1 8 2 5 9",
          "explanation": "Another valid Sudoku with unique solution."
        }
      ],
      "hidden_test_cases": [
        {
          "input": "0 0 0 0 0 0 6 8 0\n0 0 0 0 7 3 0 0 9\n3 0 9 0 0 0 0 4 5\n4 9 0 0 0 0 0 0 0\n8 0 3 0 5 0 9 0 2\n0 0 0 0 0 0 0 3 6\n9 6 0 0 0 0 3 0 8\n7 0 0 6 8 0 0 0 0\n0 2 8 0 0 0 0 0 0",
          "output": "1 7 2 5 4 9 6 8 3\n6 4 5 8 7 3 2 1 9\n3 8 9 2 6 1 7 4 5\n4 9 6 3 2 7 8 5 1\n8 1 3 4 5 6 9 7 2\n2 5 7 1 9 8 4 3 6\n9 6 4 7 1 5 3 2 8\n7 3 1 6 8 2 5 9 4\n5 2 8 9 3 4 1 6 7"
        },
        {
          "input": "0 2 0 0 0 0 0 0 0\n0 0 0 6 0 0 0 0 3\n0 7 4 0 8 0 0 0 0\n0 0 0 0 0 3 0 0 2\n0 8 0 0 4 0 0 1 0\n6 0 0 5 0 0 0 0 0\n0 0 0 0 1 0 7 8 0\n5 0 0 0 0 9 0 0 0\n0 0 0 0 0 0 0 4 0",
          "output": "1 2 6 4 3 7 9 5 8\n8 9 5 6 2 1 4 7 3\n3 7 4 9 8 5 1 2 6\n4 5 7 1 9 3 8 6 2\n9 8 3 2 4 6 5 1 7\n6 1 2 5 7 8 3 9 4\n2 6 9 3 1 4 7 8 5\n5 4 8 7 6 9 2 3 1\n7 3 1 8 5 2 6 4 9"
        },
        {
          "input": "8 0 0 0 0 0 0 0 0\n0 0 3 6 0 0 0 0 0\n0 7 0 0 9 0 2 0 0\n0 5 0 0 0 7 0 0 0\n0 0 0 0 4 5 7 0 0\n0 0 0 1 0 0 0 3 0\n0 0 1 0 0 0 0 6 8\n0 0 8 5 0 0 0 1 0\n0 9 0 0 0 0 4 0 0",
          "output": "8 1 2 7 5 3 6 4 9\n9 4 3 6 8 2 1 7 5\n6 7 5 4 9 1 2 8 3\n1 5 4 2 3 7 8 9 6\n3 6 9 8 4 5 7 2 1\n2 8 7 1 6 9 5 3 4\n5 2 1 9 7 4 3 6 8\n4 3 8 5 2 6 9 1 7\n7 9 6 3 1 8 4 5 2"
        },
        {
          "input": "0 0 0 0 0 0 0 1 2\n0 0 0 0 3 5 0 0 0\n0 0 0 6 0 0 7 0 0\n7 0 0 0 0 0 3 0 0\n0 0 0 4 0 0 8 0 0\n1 0 0 0 0 0 0 0 0\n0 0 0 1 2 0 0 0 0\n0 8 0 0 0 0 0 4 0\n0 5 0 0 0 0 6 0 0",
          "output": "6 7 3 8 9 4 5 1 2\n9 1 2 7 3 5 4 8 6\n8 4 5 6 1 2 7 9 3\n7 9 8 2 6 1 3 5 4\n5 2 6 4 7 3 8 1 9\n1 3 4 5 8 9 2 6 7\n4 6 9 1 2 8 3 7 5\n2 8 1 3 5 7 9 4 6\n3 5 7 9 4 6 1 2 8"
        }
      ]
    },
    {
      "question_number": 7,
      "title": "Snake Pattern Matrix Traversal with Obstacles",
      "category": "2D Arrays & Path Finding",
      "marks": 25,
      "time_estimate_minutes": 54,
      "content": "# Snake Pattern Traversal (25 Marks)\n\nTraverse a matrix in snake pattern while avoiding obstacles and collecting maximum value.\n\n## Problem Statement:\n\nGiven an N\u00d7M matrix with values and obstacles (-1), traverse in snake pattern:\n- Row 0: Left to right\n- Row 1: Right to left\n- Row 2: Left to right\n- Continue alternating...\n\nSkip obstacles and collect sum of all visited cells.\n\n## Visualization (4\u00d75 matrix):\n\n**Input Matrix:**\n\n|  3 |  5 |  2 |  8 |  1 |\n|:--:|:--:|:--:|:--:|:--:|:-:|\n|  7 | -1 |  4 |  6 |  9 |\n|  2 |  3 | -1 |  5 |  1 |\n| 10 |  4 |  6 |  2 |  8 |\n\n**Step-by-Step Traversal:**\n\n**Step 1:** Row 0 (left\u2192right): 3, 5, 2, 8, 1\n\n| \u21923 | \u21925 | \u21922 | \u21928 | \u21921 |\n|:--:|:--:|:--:|:--:|:--:|\n|  7 | -1 |  4 |  6 |  9 |\n|  2 |  3 | -1 |  5 |  1 |\n| 10 |  4 |  6 |  2 |  8 |\n\n**Sum so far:** 3+5+2+8+1 = 19\n\n**Step 2:** Row 1 (right\u2192left): 9, 6, 4, skip(-1), 7\n\n|  3 |  5 |  2 |  8 |  1 |\n|:--:|:--:|:--:|:--:|:--:|\n| \u21907 | \u2717  | \u21904 | \u21906 | \u21909 |\n|  2 |  3 | -1 |  5 |  1 |\n| 10 |  4 |  6 |  2 |  8 |\n\n**Sum so far:** 19 + 9+6+4+7 = 45\n\n**Step 3:** Row 2 (left\u2192right): 2, 3, skip(-1), 5, 1\n\n|  3 |  5 |  2 |  8 |  1 |\n|:--:|:--:|:--:|:--:|:--:|\n|  7 | -1 |  4 |  6 |  9 |\n| \u21922 | \u21923 | \u2717  | \u21925 | \u21921 |\n| 10 |  4 |  6 |  2 |  8 |\n\n**Sum so far:** 45 + 2+3+5+1 = 56\n\n**Step 4:** Row 3 (right\u2192left): 8, 2, 6, 4, 10\n\n|  3 |  5 |  2 |  8 |  1 |\n|:--:|:--:|:--:|:--:|:--:|\n|  7 | -1 |  4 |  6 |  9 |\n|  2 |  3 | -1 |  5 |  1 |\n| \u219010| \u21904 | \u21906 | \u21902 | \u21908 |\n\n**Final Sum:** 56 + 8+2+6+4+10 = **86**\n\n## Advanced Version:\n\nFind path with **maximum sum** when you can:\n- Move right or down only\n- Skip obstacles\n- Use dynamic programming\n\n## Requirements:\n\n- Implement `int snakeTraversal(int** matrix, int n, int m)`\n- Implement `int maxPathSum(int** matrix, int n, int m)` (DP version)\n- Handle obstacles (-1)\n- Use ONLY pointer arithmetic\n- Return -1 if no valid path exists\n\n## Constraints:\n\n- 1 \u2264 N, M \u2264 100\n- -1 \u2264 matrix[i][j] \u2264 1000\n- -1 represents obstacle\n- Time complexity: O(N\u00d7M)\n- Space complexity: O(N\u00d7M) for DP\n\n## Function Signatures:\n\n```cpp\nint snakeTraversal(int** matrix, int n, int m);\nint maxPathSum(int** matrix, int n, int m);\nbool hasValidPath(int** matrix, int n, int m);\n```\n",
      "starter_code": "#include <iostream>\nusing namespace std;\n\nint snakeTraversal(int** matrix, int n, int m) {\n    int sum = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            // Left to right\n            for (int j = 0; j < m; j++) {\n                if (*(*(matrix + i) + j) != -1)\n                    sum += *(*(matrix + i) + j);\n            }\n        } else {\n            // Right to left\n            for (int j = m - 1; j >= 0; j--) {\n                if (*(*(matrix + i) + j) != -1)\n                    sum += *(*(matrix + i) + j);\n            }\n        }\n    }\n    \n    return sum;\n}\n\nint maxPathSum(int** matrix, int n, int m) {\n    // Create DP table\n    int** dp = new int*[n];\n    for (int i = 0; i < n; i++) {\n        *(dp + i) = new int[m];\n        for (int j = 0; j < m; j++)\n            *(*(dp + i) + j) = -1;\n    }\n    \n    // Base case\n    if (*(*(matrix + 0) + 0) != -1)\n        *(*(dp + 0) + 0) = *(*(matrix + 0) + 0);\n    \n    // Fill DP table\n    // Your code here\n    \n    int result = *(*(dp + n - 1) + m - 1);\n    \n    // Cleanup\n    for (int i = 0; i < n; i++)\n        delete[] *(dp + i);\n    delete[] dp;\n    \n    return result;\n}\n\nint main() {\n    int n, m, mode;\n    cin >> n >> m >> mode;\n    \n    int** matrix = new int*[n];\n    for (int i = 0; i < n; i++) {\n        *(matrix + i) = new int[m];\n        for (int j = 0; j < m; j++)\n            cin >> *(*(matrix + i) + j);\n    }\n    \n    int result;\n    if (mode == 1)\n        result = snakeTraversal(matrix, n, m);\n    else\n        result = maxPathSum(matrix, n, m);\n    \n    cout << result << endl;\n    \n    for (int i = 0; i < n; i++)\n        delete[] *(matrix + i);\n    delete[] matrix;\n    \n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "4 5 1\n3 5 2 8 1\n7 -1 4 6 9\n2 3 -1 5 1\n10 4 6 2 8",
          "output": "86",
          "explanation": "Snake traversal: Row0(L\u2192R): 19, Row1(R\u2192L): 26, Row2(L\u2192R): 11, Row3(R\u2192L): 30. Total: 86"
        },
        {
          "input": "3 3 2\n1 2 3\n4 5 6\n7 8 9",
          "output": "29",
          "explanation": "Max path (DP): 1\u21922\u21923\u21926\u21929 = 21 OR 1\u21924\u21927\u21928\u21929 = 29. Maximum is 29."
        }
      ],
      "hidden_test_cases": [
        {
          "input": "1 5 1\n5 10 15 20 25",
          "output": "75"
        },
        {
          "input": "3 3 1\n1 -1 3\n-1 5 -1\n7 -1 9",
          "output": "25"
        },
        {
          "input": "4 4 2\n1 3 1 5\n2 -1 4 1\n5 3 -1 3\n1 2 4 2",
          "output": "18"
        },
        {
          "input": "5 5 1\n1 2 3 4 5\n10 9 8 7 6\n11 12 13 14 15\n20 19 18 17 16\n21 22 23 24 25",
          "output": "325"
        },
        {
          "input": "6 4 2\n5 10 15 20\n-1 3 8 12\n7 -1 4 9\n2 6 -1 5\n8 3 7 -1\n4 9 2 6",
          "output": "73"
        }
      ]
    },
    {
      "question_number": 8,
      "title": "Longest Increasing Subsequence with Reconstruction",
      "category": "Dynamic Programming & Arrays",
      "marks": 25,
      "time_estimate_minutes": 60,
      "content": "# Longest Increasing Subsequence (LIS) (25 Marks)\n\nFind the longest strictly increasing subsequence and reconstruct the actual sequence.\n\n## Problem Statement:\n\nGiven an array of integers, find:\n1. Length of longest increasing subsequence (LIS)\n2. The actual subsequence elements\n3. All possible LIS if multiple exist\n\n## Example: arr = [10, 9, 2, 5, 3, 7, 101, 18]\n\n**Step-by-Step DP Table Construction:**\n\n**Initial:**\n\n| Index |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\n|:-----:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| Value | 10 |  9 |  2 |  5 |  3 |  7 | 101| 18 |\n| LIS   |  1 |  1 |  1 |  1 |  1 |  1 |  1 |  1 |\n\n**After processing index 3 (value=5):**\n- Can extend from index 2 (2 < 5)\n- LIS[3] = LIS[2] + 1 = 2\n\n| Index |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\n|:-----:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| Value | 10 |  9 |  2 |  5 |  3 |  7 | 101| 18 |\n| LIS   |  1 |  1 |  1 |  2 |  1 |  1 |  1 |  1 |\n\n**After processing index 5 (value=7):**\n- Can extend from index 3 (5 < 7)\n- LIS[5] = LIS[3] + 1 = 3\n\n| Index |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\n|:-----:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| Value | 10 |  9 |  2 |  5 |  3 |  7 | 101| 18 |\n| LIS   |  1 |  1 |  1 |  2 |  2 |  3 |  1 |  1 |\n\n**Final DP Table:**\n\n| Index |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |\n|:-----:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| Value | 10 |  9 |  2 |  5 |  3 |  7 | 101| 18 |\n| LIS   |  1 |  1 |  1 |  2 |  2 |  3 |  4 |  4 |\n\n**LIS Length:** 4\n\n**Reconstruction (backtrack from max LIS):**\n- Start at index 7 (LIS=4, value=18)\n- Find previous with LIS=3 and value < 18: index 5 (value=7)\n- Find previous with LIS=2 and value < 7: index 3 (value=5)\n- Find previous with LIS=1 and value < 5: index 2 (value=2)\n\n**LIS Sequence:** [2, 5, 7, 18]\n\n## Alternative LIS:\n[2, 5, 7, 101] also has length 4\n\n## Requirements:\n\n- Implement `int findLIS(int* arr, int n, int** lisSeq)`\n- Implement `void reconstructLIS(int* arr, int* dp, int n, int* result)`\n- Use dynamic programming O(n\u00b2) or O(n log n)\n- Use ONLY pointer arithmetic\n- Return length and actual sequence\n\n## Constraints:\n\n- 1 \u2264 N \u2264 2500\n- -10\u2076 \u2264 arr[i] \u2264 10\u2076\n- Time complexity: O(n\u00b2) acceptable, O(n log n) bonus\n- Space complexity: O(n)\n\n## Function Signatures:\n\n```cpp\nint findLIS(int* arr, int n);\nvoid reconstructLIS(int* arr, int* dp, int* parent, int n, int* result, int& len);\nint binarySearch(int* tail, int len, int key);\n```\n",
      "starter_code": "#include <iostream>\nusing namespace std;\n\nint findLIS(int* arr, int n) {\n    int* dp = new int[n];\n    \n    // Initialize all LIS values to 1\n    for (int i = 0; i < n; i++)\n        *(dp + i) = 1;\n    \n    // Compute LIS values bottom-up\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (*(arr + j) < *(arr + i) && *(dp + i) < *(dp + j) + 1)\n                *(dp + i) = *(dp + j) + 1;\n        }\n    }\n    \n    // Find maximum\n    int maxLIS = 1;\n    for (int i = 0; i < n; i++)\n        if (*(dp + i) > maxLIS)\n            maxLIS = *(dp + i);\n    \n    delete[] dp;\n    return maxLIS;\n}\n\nvoid reconstructLIS(int* arr, int* dp, int* parent, int n, int* result, int& len) {\n    // Find index with maximum LIS\n    int maxIdx = 0;\n    for (int i = 1; i < n; i++)\n        if (*(dp + i) > *(dp + maxIdx))\n            maxIdx = i;\n    \n    len = *(dp + maxIdx);\n    \n    // Backtrack using parent array\n    int idx = maxIdx;\n    for (int i = len - 1; i >= 0; i--) {\n        *(result + i) = *(arr + idx);\n        idx = *(parent + idx);\n    }\n}\n\nint findLISWithReconstruction(int* arr, int n, int* result) {\n    int* dp = new int[n];\n    int* parent = new int[n];\n    \n    for (int i = 0; i < n; i++) {\n        *(dp + i) = 1;\n        *(parent + i) = -1;\n    }\n    \n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (*(arr + j) < *(arr + i) && *(dp + i) < *(dp + j) + 1) {\n                *(dp + i) = *(dp + j) + 1;\n                *(parent + i) = j;\n            }\n        }\n    }\n    \n    int len;\n    reconstructLIS(arr, dp, parent, n, result, len);\n    \n    delete[] dp;\n    delete[] parent;\n    \n    return len;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    int* arr = new int[n];\n    for (int i = 0; i < n; i++)\n        cin >> *(arr + i);\n    \n    int* result = new int[n];\n    int len = findLISWithReconstruction(arr, n, result);\n    \n    cout << len << endl;\n    for (int i = 0; i < len; i++)\n        cout << *(result + i) << \" \";\n    cout << endl;\n    \n    delete[] arr;\n    delete[] result;\n    \n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "8\n10 9 2 5 3 7 101 18",
          "output": "4\n2 5 7 18",
          "explanation": "LIS of length 4: [2,5,7,18]. Another valid: [2,5,7,101]"
        },
        {
          "input": "6\n0 1 0 3 2 3",
          "output": "4\n0 1 2 3",
          "explanation": "LIS: [0,1,2,3] with length 4"
        }
      ],
      "hidden_test_cases": [
        {
          "input": "1\n42",
          "output": "1\n42"
        },
        {
          "input": "5\n5 4 3 2 1",
          "output": "1\n5"
        },
        {
          "input": "10\n3 10 2 1 20 4 5 6 7 8",
          "output": "6\n2 4 5 6 7 8"
        },
        {
          "input": "12\n1 3 6 7 9 4 10 5 6 11 12 13",
          "output": "8\n1 3 4 5 6 11 12 13"
        },
        {
          "input": "15\n50 3 10 7 40 80 5 12 15 20 25 30 35 40 45",
          "output": "9\n5 12 15 20 25 30 35 40 45"
        }
      ]
    },
    {
      "question_number": 9,
      "title": "Knapsack Problem with Item Tracking",
      "category": "Dynamic Programming & Optimization",
      "marks": 25,
      "time_estimate_minutes": 57,
      "content": "# 0/1 Knapsack with Item Selection (25 Marks)\n\nSolve the classic 0/1 knapsack problem and track which items are selected.\n\n## Problem Statement:\n\nGiven:\n- N items with weights and values\n- Knapsack capacity W\n\nFind:\n1. Maximum value achievable\n2. Which items to select\n3. Total weight used\n\n## Example: Capacity = 10\n\n**Items:**\n\n| Item | Weight | Value | Value/Weight |\n|:----:|:------:|:-----:|:------------:|\n|  1   |   2    |  10   |     5.0      |\n|  2   |   3    |  15   |     5.0      |\n|  3   |   5    |  25   |     5.0      |\n|  4   |   7    |  30   |     4.3      |\n\n**DP Table Construction:**\n\n**dp[i][w] = max value using first i items with capacity w**\n\n**Partial DP Table (showing key cells):**\n\n|  i\\w  |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 |\n|:-----:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|   0   |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |  0 |\n| 1(2,10)|  0 |  0 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 |\n| 2(3,15)|  0 |  0 | 10 | 15 | 15 | 25 | 25 | 25 | 25 | 25 | 25 |\n| 3(5,25)|  0 |  0 | 10 | 15 | 15 | 25 | 25 | 35 | 40 | 40 | 50 |\n| 4(7,30)|  0 |  0 | 10 | 15 | 15 | 25 | 25 | 35 | 40 | 40 | 50 |\n\n**Backtracking to find items:**\n\nStart at dp[4][10] = 50\n- dp[4][10] \u2260 dp[3][10] \u2192 Item 4 NOT taken\n- Move to dp[3][10] = 50\n- dp[3][10] \u2260 dp[2][10] \u2192 Item 3 IS taken (weight=5, value=25)\n- Move to dp[2][5] = 25\n- dp[2][5] \u2260 dp[1][5] \u2192 Item 2 IS taken (weight=3, value=15)\n- Move to dp[1][2] = 10\n- dp[1][2] \u2260 dp[0][2] \u2192 Item 1 IS taken (weight=2, value=10)\n\n**Selected Items:** 1, 2, 3\n**Total Weight:** 2 + 3 + 5 = 10\n**Total Value:** 10 + 15 + 25 = 50\n\n## Recurrence Relation:\n\n```\ndp[i][w] = max(\n    dp[i-1][w],                    // Don't take item i\n    dp[i-1][w-weight[i]] + value[i] // Take item i\n)\n```\n\n## Requirements:\n\n- Implement `int knapsack(int* weights, int* values, int n, int capacity, int* selected)`\n- Use 2D DP table\n- Backtrack to find selected items\n- Use ONLY pointer arithmetic\n- Handle edge cases (capacity=0, n=0)\n\n## Constraints:\n\n- 1 \u2264 N \u2264 100\n- 1 \u2264 W \u2264 1000\n- 1 \u2264 weights[i] \u2264 W\n- 1 \u2264 values[i] \u2264 1000\n- Time complexity: O(N\u00d7W)\n- Space complexity: O(N\u00d7W)\n\n## Input Format:\n```\nN W\nweight1 value1\nweight2 value2\n...\n```\n\n## Output Format:\n```\nMaxValue\nSelectedItems (1-indexed, space-separated)\nTotalWeight\n```\n\n## Function Signatures:\n\n```cpp\nint knapsack(int* weights, int* values, int n, int capacity, int* selected);\nvoid backtrack(int** dp, int* weights, int n, int capacity, int* selected);\n```\n",
      "starter_code": "#include <iostream>\nusing namespace std;\n\nvoid backtrack(int** dp, int* weights, int n, int capacity, int* selected, int& count) {\n    int w = capacity;\n    count = 0;\n    \n    for (int i = n; i > 0 && w > 0; i--) {\n        // If value comes from including current item\n        if (*(*(dp + i) + w) != *(*(dp + i - 1) + w)) {\n            *(selected + count) = i; // 1-indexed\n            count++;\n            w -= *(weights + i - 1);\n        }\n    }\n    \n    // Reverse selected array\n    for (int i = 0; i < count / 2; i++) {\n        int temp = *(selected + i);\n        *(selected + i) = *(selected + count - 1 - i);\n        *(selected + count - 1 - i) = temp;\n    }\n}\n\nint knapsack(int* weights, int* values, int n, int capacity, int* selected) {\n    // Create DP table\n    int** dp = new int*[n + 1];\n    for (int i = 0; i <= n; i++) {\n        *(dp + i) = new int[capacity + 1];\n        for (int w = 0; w <= capacity; w++)\n            *(*(dp + i) + w) = 0;\n    }\n    \n    // Fill DP table\n    for (int i = 1; i <= n; i++) {\n        for (int w = 1; w <= capacity; w++) {\n            // Don't take item\n            *(*(dp + i) + w) = *(*(dp + i - 1) + w);\n            \n            // Take item if possible\n            if (*(weights + i - 1) <= w) {\n                int takeValue = *(*(dp + i - 1) + w - *(weights + i - 1)) + *(values + i - 1);\n                if (takeValue > *(*(dp + i) + w))\n                    *(*(dp + i) + w) = takeValue;\n            }\n        }\n    }\n    \n    int maxValue = *(*(dp + n) + capacity);\n    \n    // Backtrack to find items\n    int count;\n    backtrack(dp, weights, n, capacity, selected, count);\n    \n    // Cleanup\n    for (int i = 0; i <= n; i++)\n        delete[] *(dp + i);\n    delete[] dp;\n    \n    return maxValue;\n}\n\nint main() {\n    int n, capacity;\n    cin >> n >> capacity;\n    \n    int* weights = new int[n];\n    int* values = new int[n];\n    int* selected = new int[n];\n    \n    for (int i = 0; i < n; i++)\n        cin >> *(weights + i) >> *(values + i);\n    \n    int maxValue = knapsack(weights, values, n, capacity, selected);\n    \n    cout << maxValue << endl;\n    \n    // Print selected items\n    int count = 0;\n    int totalWeight = 0;\n    for (int i = 0; i < n; i++) {\n        if (*(selected + i) != 0) {\n            cout << *(selected + i) << \" \";\n            totalWeight += *(weights + *(selected + i) - 1);\n            count++;\n        }\n    }\n    cout << endl << totalWeight << endl;\n    \n    delete[] weights;\n    delete[] values;\n    delete[] selected;\n    \n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "4 10\n2 10\n3 15\n5 25\n7 30",
          "output": "50\n1 2 3\n10",
          "explanation": "Select items 1,2,3 with total weight=10 and value=50"
        },
        {
          "input": "5 15\n12 4\n2 2\n1 1\n4 10\n1 2",
          "output": "15\n2 3 4 5\n8",
          "explanation": "Select items 2,3,4,5 with weight=8 and value=15"
        }
      ],
      "hidden_test_cases": [
        {
          "input": "1 5\n3 10",
          "output": "10\n1\n3"
        },
        {
          "input": "3 5\n6 30\n3 14\n4 16",
          "output": "14\n2\n3"
        },
        {
          "input": "6 20\n5 30\n10 50\n15 100\n3 20\n2 15\n8 40",
          "output": "165\n1 2 4 5\n20"
        },
        {
          "input": "8 50\n10 60\n20 100\n30 120\n5 30\n15 80\n25 110\n12 70\n8 50",
          "output": "390\n1 2 4 5 7 8\n50"
        },
        {
          "input": "10 100\n23 92\n31 57\n29 49\n44 68\n53 60\n38 43\n63 67\n85 84\n89 87\n82 72",
          "output": "309\n1 2 3 4 7\n100"
        }
      ]
    },
    {
      "question_number": 10,
      "title": "Hospital Emergency Room Management System",
      "category": "Priority Queues & Dynamic Arrays",
      "marks": 25,
      "time_estimate_minutes": 56,
      "content": "# Hospital ER Management System (25 Marks)\n\nImplement an emergency room patient management system with priority-based treatment.\n\n## System Requirements:\n\n### Patient Structure:\n```cpp\nstruct Patient {\n    int id;\n    char name[50];\n    int priority;      // 1=Critical, 2=Urgent, 3=Normal\n    int arrivalTime;\n    int treatmentTime; // Minutes needed\n};\n```\n\n### Operations:\n\n1. **ADD_PATIENT**: Add patient to queue\n2. **TREAT_NEXT**: Treat highest priority patient (FCFS within same priority)\n3. **UPDATE_PRIORITY**: Change patient priority (e.g., condition worsens)\n4. **REMOVE_PATIENT**: Remove patient (e.g., transferred)\n5. **GET_WAIT_TIME**: Calculate expected wait time for patient\n6. **SHOW_QUEUE**: Display current queue state\n\n## Example Scenario:\n\n**Initial Queue:**\n\n| Position | ID  | Name  | Priority | Arrival | Treatment |\n|:--------:|:---:|:-----:|:--------:|:-------:|:---------:|\n|    1     | 101 | Alice |    3     |   0     |    15     |\n|    2     | 102 | Bob   |    2     |   5     |    20     |\n|    3     | 103 | Carol |    1     |   10    |    30     |\n\n**After Operations:**\n\n**Operation 1:** `ADD_PATIENT 104 David 2 15 25`\n\n**Queue (sorted by priority, then arrival):**\n\n| Position | ID  | Name  | Priority | Arrival | Treatment |\n|:--------:|:---:|:-----:|:--------:|:-------:|:---------:|\n|    1     | 103 | Carol |    1     |   10    |    30     |\n|    2     | 102 | Bob   |    2     |   5     |    20     |\n|    3     | 104 | David |    2     |   15    |    25     |\n|    4     | 101 | Alice |    3     |   0     |    15     |\n\n**Operation 2:** `TREAT_NEXT`\n- Treats Carol (ID 103, Priority 1)\n- Current time: 30 minutes\n\n**Remaining Queue:**\n\n| Position | ID  | Name  | Priority | Arrival | Wait Time |\n|:--------:|:---:|:-----:|:--------:|:-------:|:---------:|\n|    1     | 102 | Bob   |    2     |   5     |    25     |\n|    2     | 104 | David |    2     |   15    |    15     |\n|    3     | 101 | Alice |    3     |   0     |    30     |\n\n**Operation 3:** `UPDATE_PRIORITY 101 1`\n- Alice's condition worsens to Critical\n\n**Updated Queue:**\n\n| Position | ID  | Name  | Priority | Arrival | Wait Time |\n|:--------:|:---:|:-----:|:--------:|:-------:|:---------:|\n|    1     | 101 | Alice |    1     |   0     |    30     |\n|    2     | 102 | Bob   |    2     |   5     |    25     |\n|    3     | 104 | David |    2     |   15    |    15     |\n\n**Operation 4:** `GET_WAIT_TIME 104`\n- David must wait for: Alice (15 min) + Bob (20 min) = 35 minutes\n\n## Requirements:\n\n- Implement priority queue using dynamic array\n- Maintain heap property OR sorted array\n- Use ONLY pointer arithmetic\n- Handle all operations efficiently\n- Calculate accurate wait times\n\n## Constraints:\n\n- 1 \u2264 Number of patients \u2264 500\n- 1 \u2264 Priority \u2264 3 (1=highest)\n- 0 \u2264 Arrival time \u2264 1440 (24 hours in minutes)\n- 5 \u2264 Treatment time \u2264 120 minutes\n- Operations: up to 1000\n\n## Input Format:\n```\nN (number of operations)\nOperation parameters...\n```\n\n## Output Format:\n```\nFor each operation:\n- ADD: \"ADDED patientID\"\n- TREAT: \"TREATED patientID name\"\n- UPDATE: \"UPDATED patientID priority\"\n- REMOVE: \"REMOVED patientID\"\n- WAIT_TIME: \"WAIT waitMinutes\"\n- SHOW: Display queue\n```\n\n## Function Signatures:\n\n```cpp\nstruct Patient {\n    int id;\n    char name[50];\n    int priority;\n    int arrivalTime;\n    int treatmentTime;\n};\n\nvoid addPatient(Patient** queue, int& size, Patient p);\nPatient treatNext(Patient** queue, int& size, int& currentTime);\nvoid updatePriority(Patient* queue, int size, int id, int newPriority);\nvoid removePatient(Patient** queue, int& size, int id);\nint getWaitTime(Patient* queue, int size, int id, int currentTime);\nvoid heapifyUp(Patient* queue, int index);\nvoid heapifyDown(Patient* queue, int size, int index);\n```\n",
      "starter_code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nstruct Patient {\n    int id;\n    char name[50];\n    int priority;\n    int arrivalTime;\n    int treatmentTime;\n};\n\nbool hasHigherPriority(Patient a, Patient b) {\n    if (a.priority != b.priority)\n        return a.priority < b.priority; // Lower number = higher priority\n    return a.arrivalTime < b.arrivalTime; // FCFS within same priority\n}\n\nvoid addPatient(Patient** queue, int& size, int& capacity, Patient p) {\n    // Resize if needed\n    if (size >= capacity) {\n        capacity *= 2;\n        Patient* newQueue = new Patient[capacity];\n        for (int i = 0; i < size; i++)\n            *(newQueue + i) = *((*queue) + i);\n        delete[] *queue;\n        *queue = newQueue;\n    }\n    \n    // Add patient and maintain sorted order\n    *((*queue) + size) = p;\n    size++;\n    \n    // Sort (insertion sort for simplicity)\n    for (int i = size - 1; i > 0; i--) {\n        if (hasHigherPriority(*((*queue) + i), *((*queue) + i - 1))) {\n            Patient temp = *((*queue) + i);\n            *((*queue) + i) = *((*queue) + i - 1);\n            *((*queue) + i - 1) = temp;\n        } else {\n            break;\n        }\n    }\n}\n\nPatient treatNext(Patient** queue, int& size, int& currentTime) {\n    Patient treated = **queue;\n    currentTime += treated.treatmentTime;\n    \n    // Shift array\n    for (int i = 0; i < size - 1; i++)\n        *((*queue) + i) = *((*queue) + i + 1);\n    size--;\n    \n    return treated;\n}\n\nvoid updatePriority(Patient* queue, int size, int id, int newPriority) {\n    for (int i = 0; i < size; i++) {\n        if ((queue + i)->id == id) {\n            (queue + i)->priority = newPriority;\n            \n            // Re-sort\n            Patient temp = *(queue + i);\n            int j = i;\n            while (j > 0 && hasHigherPriority(temp, *(queue + j - 1))) {\n                *(queue + j) = *(queue + j - 1);\n                j--;\n            }\n            *(queue + j) = temp;\n            break;\n        }\n    }\n}\n\nvoid removePatient(Patient** queue, int& size, int id) {\n    int idx = -1;\n    for (int i = 0; i < size; i++) {\n        if (((*queue) + i)->id == id) {\n            idx = i;\n            break;\n        }\n    }\n    \n    if (idx != -1) {\n        for (int i = idx; i < size - 1; i++)\n            *((*queue) + i) = *((*queue) + i + 1);\n        size--;\n    }\n}\n\nint getWaitTime(Patient* queue, int size, int id, int currentTime) {\n    int waitTime = 0;\n    for (int i = 0; i < size; i++) {\n        if ((queue + i)->id == id)\n            return waitTime;\n        waitTime += (queue + i)->treatmentTime;\n    }\n    return -1;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    int capacity = 10;\n    Patient* queue = new Patient[capacity];\n    int size = 0;\n    int currentTime = 0;\n    \n    for (int i = 0; i < n; i++) {\n        char operation[20];\n        cin >> operation;\n        \n        if (strcmp(operation, \"ADD\") == 0) {\n            Patient p;\n            cin >> p.id >> p.name >> p.priority >> p.arrivalTime >> p.treatmentTime;\n            addPatient(&queue, size, capacity, p);\n            cout << \"ADDED \" << p.id << endl;\n        }\n        else if (strcmp(operation, \"TREAT\") == 0) {\n            if (size > 0) {\n                Patient treated = treatNext(&queue, size, currentTime);\n                cout << \"TREATED \" << treated.id << \" \" << treated.name << endl;\n            }\n        }\n        else if (strcmp(operation, \"UPDATE\") == 0) {\n            int id, newPriority;\n            cin >> id >> newPriority;\n            updatePriority(queue, size, id, newPriority);\n            cout << \"UPDATED \" << id << \" \" << newPriority << endl;\n        }\n        else if (strcmp(operation, \"REMOVE\") == 0) {\n            int id;\n            cin >> id;\n            removePatient(&queue, size, id);\n            cout << \"REMOVED \" << id << endl;\n        }\n        else if (strcmp(operation, \"WAIT\") == 0) {\n            int id;\n            cin >> id;\n            int wait = getWaitTime(queue, size, id, currentTime);\n            cout << \"WAIT \" << wait << endl;\n        }\n    }\n    \n    delete[] queue;\n    return 0;\n}",
      "visible_test_cases": [
        {
          "input": "6\nADD 101 Alice 3 0 15\nADD 102 Bob 2 5 20\nADD 103 Carol 1 10 30\nADD 104 David 2 15 25\nTREAT\nWAIT 104",
          "output": "ADDED 101\nADDED 102\nADDED 103\nADDED 104\nTREATED 103 Carol\nWAIT 20",
          "explanation": "Carol treated first (priority 1). David waits for Bob (20 min)."
        },
        {
          "input": "5\nADD 201 Eve 3 0 10\nADD 202 Frank 2 5 15\nUPDATE 201 1\nTREAT\nTREAT",
          "output": "ADDED 201\nADDED 202\nUPDATED 201 1\nTREATED 201 Eve\nTREATED 202 Frank",
          "explanation": "Eve's priority updated to 1, treated first."
        }
      ],
      "hidden_test_cases": [
        {
          "input": "3\nADD 301 Grace 1 0 20\nTREAT\nWAIT 301",
          "output": "ADDED 301\nTREATED 301 Grace\nWAIT -1"
        },
        {
          "input": "7\nADD 401 Henry 2 0 10\nADD 402 Ivy 2 5 15\nADD 403 Jack 1 10 20\nREMOVE 402\nTREAT\nADD 404 Kate 3 20 25\nWAIT 404",
          "output": "ADDED 401\nADDED 402\nADDED 403\nREMOVED 402\nTREATED 403 Jack\nADDED 404\nWAIT 10"
        },
        {
          "input": "10\nADD 501 Leo 3 0 5\nADD 502 Mia 2 2 10\nADD 503 Noah 1 5 15\nADD 504 Olivia 2 8 12\nTREAT\nUPDATE 501 1\nTREAT\nWAIT 504\nREMOVE 504\nWAIT 504",
          "output": "ADDED 501\nADDED 502\nADDED 503\nADDED 504\nTREATED 503 Noah\nUPDATED 501 1\nTREATED 501 Leo\nWAIT 10\nREMOVED 504\nWAIT -1"
        }
      ]
    }
  ]
}