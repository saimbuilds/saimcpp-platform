{
  "category": "Arrays 2D - Hard",
  "problems": [
    {
      "title": "Rotate Image Layers",
      "difficulty": "hard",
      "description": "Rotate each concentric layer of a square matrix independently by 90 degrees clockwise.",
      "inputFormat": "First line: n (matrix size)\\nNext n lines: n space-separated integers each",
      "outputFormat": "Print rotated matrix (n lines with n integers)",
      "constraints": "2 \u2264 n \u2264 100 (even)\\n-10^6 \u2264 matrix[i][j] \u2264 10^6",
      "sampleTestCases": [
        {
          "input": "4\\n1 2 3 4\\n5 6 7 8\\n9 10 11 12\\n13 14 15 16",
          "output": "13 9 5 1\\n14 10 6 2\\n15 11 7 3\\n16 12 8 4",
          "explanation": "Each layer rotated 90\u00b0 clockwise"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "2\\n1 2\\n3 4",
          "output": "3 1\\n4 2"
        },
        {
          "input": "6\\n1 2 3 4 5 6\\n7 8 9 10 11 12\\n13 14 15 16 17 18\\n19 20 21 22 23 24\\n25 26 27 28 29 30\\n31 32 33 34 35 36",
          "output": "31 25 19 13 7 1\\n32 26 20 14 8 2\\n33 27 21 15 9 3\\n34 28 22 16 10 4\\n35 29 23 17 11 5\\n36 30 24 18 12 6"
        }
      ],
      "points": 35,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    \\n    int matrix[100][100];\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < n; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    },
    {
      "title": "Longest Increasing Path in Matrix",
      "difficulty": "hard",
      "description": "Find length of longest increasing path in matrix. Can move up/down/left/right to adjacent cells with strictly greater values.",
      "inputFormat": "First line: r c (rows and columns)\\nNext r lines: c space-separated integers each",
      "outputFormat": "Print length of longest increasing path",
      "constraints": "1 \u2264 r, c \u2264 100\\n1 \u2264 matrix[i][j] \u2264 10^6",
      "sampleTestCases": [
        {
          "input": "3 3\\n9 9 4\\n6 6 8\\n2 1 1",
          "output": "4",
          "explanation": "Path: 1\u21922\u21926\u21929 has length 4"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "3 3\\n3 4 5\\n3 2 6\\n2 2 1",
          "output": "4"
        },
        {
          "input": "1 1\\n5",
          "output": "1"
        },
        {
          "input": "4 4\\n1 2 3 4\\n8 7 6 5\\n9 10 11 12\\n16 15 14 13",
          "output": "7"
        }
      ],
      "points": 38,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int r, c;\\n    cin >> r >> c;\\n    \\n    int matrix[100][100];\\n    for(int i = 0; i < r; i++) {\\n        for(int j = 0; j < c; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    },
    {
      "title": "Minimum Path Sum",
      "difficulty": "hard",
      "description": "Find minimum sum path from top-left to bottom-right. Can only move right or down.",
      "inputFormat": "First line: r c (rows and columns)\\nNext r lines: c space-separated positive integers",
      "outputFormat": "Print minimum path sum",
      "constraints": "1 \u2264 r, c \u2264 100\\n1 \u2264 matrix[i][j] \u2264 1000",
      "sampleTestCases": [
        {
          "input": "3 3\\n1 3 1\\n1 5 1\\n4 2 1",
          "output": "7",
          "explanation": "Path: 1\u21923\u21921\u21921\u21921 = 7"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "2 2\\n1 2\\n1 1",
          "output": "3"
        },
        {
          "input": "1 4\\n5 10 15 20",
          "output": "50"
        },
        {
          "input": "4 4\\n1 1 1 1\\n1 100 1 1\\n1 1 1 1\\n1 1 1 1",
          "output": "7"
        }
      ],
      "points": 32,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int r, c;\\n    cin >> r >> c;\\n    \\n    int matrix[100][100];\\n    for(int i = 0; i < r; i++) {\\n        for(int j = 0; j < c; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    },
    {
      "title": "Unique Paths with Obstacles",
      "difficulty": "hard",
      "description": "Count unique paths from top-left to bottom-right (only right/down moves). 0=empty, 1=obstacle.",
      "inputFormat": "First line: r c (rows and columns)\\nNext r lines: c space-separated 0s and 1s",
      "outputFormat": "Print number of unique paths",
      "constraints": "1 \u2264 r, c \u2264 100\\nmatrix[i][j] \u2208 {0, 1}",
      "sampleTestCases": [
        {
          "input": "3 3\\n0 0 0\\n0 1 0\\n0 0 0",
          "output": "2",
          "explanation": "Two paths avoiding the obstacle at (1,1)"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "2 2\\n0 0\\n0 0",
          "output": "2"
        },
        {
          "input": "3 3\\n0 0 0\\n0 0 0\\n0 0 0",
          "output": "6"
        },
        {
          "input": "2 3\\n0 1 0\\n0 0 0",
          "output": "1"
        }
      ],
      "points": 34,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int r, c;\\n    cin >> r >> c;\\n    \\n    int matrix[100][100];\\n    for(int i = 0; i < r; i++) {\\n        for(int j = 0; j < c; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    },
    {
      "title": "Word Search in Matrix",
      "difficulty": "hard",
      "description": "Search if a word exists in matrix. Can move up/down/left/right. Each cell used once per search. Print 'YES' or 'NO'.",
      "inputFormat": "First line: r c (rows and columns)\\nNext r lines: c space-separated characters\\nLast line: word to search",
      "outputFormat": "Print 'YES' if word found, 'NO' otherwise",
      "constraints": "1 \u2264 r, c \u2264 50\\n1 \u2264 word length \u2264 100",
      "sampleTestCases": [
        {
          "input": "3 4\\nA B C E\\nS F C S\\nA D E E\\nABCCED",
          "output": "YES",
          "explanation": "Word ABCCED found in matrix"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "3 4\\nA B C E\\nS F C S\\nA D E E\\nSEE",
          "output": "YES"
        },
        {
          "input": "3 4\\nA B C E\\nS F C S\\nA D E E\\nABCB",
          "output": "NO"
        },
        {
          "input": "1 1\\nA\\nA",
          "output": "YES"
        }
      ],
      "points": 40,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int r, c;\\n    cin >> r >> c;\\n    \\n    char matrix[50][50];\\n    for(int i = 0; i < r; i++) {\\n        for(int j = 0; j < c; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    string word;\\n    cin >> word;\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    },
    {
      "title": "Maximal Square",
      "difficulty": "hard",
      "description": "Find area of largest square containing only 1s in binary matrix.",
      "inputFormat": "First line: r c (rows and columns)\\nNext r lines: c space-separated 0s and 1s",
      "outputFormat": "Print maximum square area",
      "constraints": "1 \u2264 r, c \u2264 100\\nmatrix[i][j] \u2208 {0, 1}",
      "sampleTestCases": [
        {
          "input": "4 5\\n1 0 1 0 0\\n1 0 1 1 1\\n1 1 1 1 1\\n1 0 0 1 0",
          "output": "4",
          "explanation": "2\u00d72 square at bottom-right has area 4"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "2 2\\n0 1\\n1 0",
          "output": "1"
        },
        {
          "input": "3 3\\n1 1 1\\n1 1 1\\n1 1 1",
          "output": "9"
        },
        {
          "input": "5 5\\n0 1 1 1 0\\n1 1 1 1 1\\n0 1 1 1 1\\n0 1 1 1 1\\n0 0 1 1 1",
          "output": "16"
        }
      ],
      "points": 36,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int r, c;\\n    cin >> r >> c;\\n    \\n    int matrix[100][100];\\n    for(int i = 0; i < r; i++) {\\n        for(int j = 0; j < c; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    },
    {
      "title": "Dungeon Game",
      "difficulty": "hard",
      "description": "Find minimum initial health needed to reach bottom-right from top-left. Health never drops below 1. Negative values reduce health.",
      "inputFormat": "First line: r c (rows and columns)\\nNext r lines: c space-separated integers (positive=gain, negative=loss)",
      "outputFormat": "Print minimum initial health required",
      "constraints": "1 \u2264 r, c \u2264 100\\n-1000 \u2264 matrix[i][j] \u2264 1000",
      "sampleTestCases": [
        {
          "input": "3 3\\n-2 -3 3\\n-5 -10 1\\n10 30 -5",
          "output": "7",
          "explanation": "Start with 7 health, path: -2\u2192-3\u21923\u21921\u2192-5 keeps health \u22651"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "1 1\\n0",
          "output": "1"
        },
        {
          "input": "2 2\\n1 -3\\n-2 -4",
          "output": "4"
        },
        {
          "input": "3 3\\n0 0 0\\n0 0 0\\n0 0 0",
          "output": "1"
        }
      ],
      "points": 40,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int r, c;\\n    cin >> r >> c;\\n    \\n    int matrix[100][100];\\n    for(int i = 0; i < r; i++) {\\n        for(int j = 0; j < c; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    },
    {
      "title": "Count Square Submatrices with All Ones",
      "difficulty": "hard",
      "description": "Count total number of square submatrices that contain all 1s.",
      "inputFormat": "First line: r c (rows and columns)\\nNext r lines: c space-separated 0s and 1s",
      "outputFormat": "Print count of square submatrices with all 1s",
      "constraints": "1 \u2264 r, c \u2264 100\\nmatrix[i][j] \u2208 {0, 1}",
      "sampleTestCases": [
        {
          "input": "3 4\\n0 1 1 1\\n1 1 1 1\\n0 1 1 1",
          "output": "15",
          "explanation": "Ten 1\u00d71, four 2\u00d72, one 3\u00d73 squares"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "2 2\\n1 1\\n1 1",
          "output": "5"
        },
        {
          "input": "3 3\\n1 0 1\\n1 1 0\\n1 1 0",
          "output": "7"
        },
        {
          "input": "1 1\\n1",
          "output": "1"
        }
      ],
      "points": 37,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int r, c;\\n    cin >> r >> c;\\n    \\n    int matrix[100][100];\\n    for(int i = 0; i < r; i++) {\\n        for(int j = 0; j < c; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    },
    {
      "title": "Shortest Path in Binary Matrix",
      "difficulty": "hard",
      "description": "Find shortest path from top-left to bottom-right in binary matrix (0=passable, 1=blocked). Can move 8 directions. Print path length or -1.",
      "inputFormat": "First line: n (matrix size)\\nNext n lines: n space-separated 0s and 1s",
      "outputFormat": "Print shortest path length or -1 if no path",
      "constraints": "1 \u2264 n \u2264 100\\nmatrix[i][j] \u2208 {0, 1}",
      "sampleTestCases": [
        {
          "input": "3\\n0 1 0\\n0 0 0\\n1 0 0",
          "output": "3",
          "explanation": "Path: (0,0)\u2192(1,1)\u2192(2,2) has length 3"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "2\\n0 0\\n0 0",
          "output": "2"
        },
        {
          "input": "3\\n0 0 0\\n1 1 0\\n0 0 0",
          "output": "4"
        },
        {
          "input": "2\\n1 0\\n0 0",
          "output": "-1"
        }
      ],
      "points": 38,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    \\n    int matrix[100][100];\\n    for(int i = 0; i < n; i++) {\\n        for(int j = 0; j < n; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    },
    {
      "title": "Surrounded Regions",
      "difficulty": "hard",
      "description": "Flip all 'O's surrounded by 'X's to 'X'. 'O's on border or connected to border are not surrounded. Print modified matrix.",
      "inputFormat": "First line: r c (rows and columns)\\nNext r lines: c space-separated characters (X or O)",
      "outputFormat": "Print modified matrix (r lines with c characters)",
      "constraints": "1 \u2264 r, c \u2264 100\\nmatrix[i][j] \u2208 {X, O}",
      "sampleTestCases": [
        {
          "input": "4 4\\nX X X X\\nX O O X\\nX X O X\\nX O X X",
          "output": "X X X X\\nX X X X\\nX X X X\\nX O X X",
          "explanation": "Only O at (3,1) connects to border, others flipped"
        }
      ],
      "hiddenTestCases": [
        {
          "input": "1 1\\nO",
          "output": "O"
        },
        {
          "input": "3 3\\nO O O\\nO X O\\nO O O",
          "output": "O O O\\nO X O\\nO O O"
        },
        {
          "input": "4 4\\nX X X X\\nX O O X\\nX O O X\\nX X X X",
          "output": "X X X X\\nX X X X\\nX X X X\\nX X X X"
        }
      ],
      "points": 35,
      "starterCode": "#include <iostream>\\nusing namespace std;\\n\\nint main() {\\n    int r, c;\\n    cin >> r >> c;\\n    \\n    char matrix[100][100];\\n    for(int i = 0; i < r; i++) {\\n        for(int j = 0; j < c; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n    \\n    // Your code here\\n    \\n    return 0;\\n}"
    }
  ]
}